import array
from typing import Sequence
import threading

import oracledb

# Attempt to initialize the Oracle client in thick mode if available.  If the
# specified client libraries are not present or the initialization fails for
# any reason, we fall back to the default thin mode.  This must happen before
# any connections or pools are created.
try:  # pragma: no cover - depends on client availability at runtime
    oracledb.init_oracle_client(
        lib_dir=r"C:\Users\Agam\Downloads\intern\pathinfotech\face\oracle23ai\dbhomeFree\bin"
    )
    print("Thick mode enabled")
except Exception:  # pragma: no cover - executed when thick mode fails
    print("Falling back to thin mode")

from .config import Config

_pool = None
_pool_lock = threading.Lock()

def _get_pool() -> oracledb.SessionPool:
    """Return a lazily constructed global session pool."""
    global _pool
    if _pool is None:
        with _pool_lock:
            if _pool is None:
                _pool = oracledb.create_pool(
                    user=Config.ORACLE_USER,
                    password=Config.ORACLE_PASSWORD,
                    dsn=Config.ORACLE_DSN,
                    min=Config.POOL_MIN,
                    max=Config.POOL_MAX,
                    increment=Config.POOL_INC,
                )
    return _pool

def get_conn() -> oracledb.Connection:
    """Return a connection from the session pool."""
    pool = _get_pool()
    return pool.acquire()


def ensure_query_identity_table(conn: oracledb.Connection) -> None:
    """Ensure the ``query_identity`` table exists.

    Some workshop environments invoke the training scripts before running the
    schema setup SQL which creates ``query_identity``.  In such cases the
    initial ``INSERT`` into the table raises ``ORA-00942`` (table or view does
    not exist).  To make the utilities more robust, create the table on demand
    when it is missing.
    """
    with conn.cursor() as cur:
        try:
            cur.execute("SELECT 1 FROM query_identity WHERE 1=0")
        except oracledb.DatabaseError as exc:  # pragma: no cover - depends on DB state
            err = exc.args[0]
            if getattr(err, "code", None) != 942:  # ORA-00942
                raise
            cur.execute(
                f"""
                CREATE TABLE query_identity (
                    qid NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    qvec VECTOR({Config.VECTOR_DIM}, FLOAT32, DENSE),
                    created_at TIMESTAMP DEFAULT SYSTIMESTAMP
                )
                """
            )

def to_vec_array(vec_f32: Sequence[float]) -> array.array:
    """Convert an iterable of float32 values to :class:`array.array`.

    Oracle 23ai's driver can error (``DPY-3002``) when numpy arrays are
    bound directly.  Converting to ``array('f', ...)`` avoids this but we
    also validate the length so that mismatched embeddings are caught
    early.

    Parameters
    ----------
    vec_f32: iterable
        Sequence of float32 values representing an embedding.

    Returns
    -------
    array.array
        Array of type ``'f'`` with length equal to ``Config.VECTOR_DIM``.

    Raises
    ------
    ValueError
        If ``vec_f32`` does not have ``Config.VECTOR_DIM`` elements.
    """
    if len(vec_f32) != Config.VECTOR_DIM:
        raise ValueError(f"expected vector of length {Config.VECTOR_DIM}")
    return array.array("f", vec_f32)  # float32

def topk_by_vector(
    conn: oracledb.Connection, query_vec: Sequence[float], k: int
) -> list[tuple]:
    """Return the ``k`` nearest neighbours using Oracle's ``VECTOR_DISTANCE``.

    The query vector is temporarily inserted into ``query_identity`` so that we
    can leverage SQL for the similarity search.  The row is cleaned up
    afterwards.
    """
    qarr = to_vec_array(query_vec)
    ensure_query_identity_table(conn)
    with conn.cursor() as cur:
        # Insert the query vector
        cur.execute("INSERT INTO query_identity(qvec) VALUES (:1)", [qarr])
        cur.execute(
            "SELECT qid FROM query_identity ORDER BY qid DESC FETCH FIRST 1 ROWS ONLY"
        )
        qid = cur.fetchone()[0]

        sql = """
        WITH q AS (SELECT qvec FROM query_identity WHERE qid = :qid)
        SELECT c.customer_id,
               VECTOR_DISTANCE(c.identity_vec, q.qvec) AS vdist,
               c.full_name, c.dob, c.phone_e164, c.email_norm, c.gov_id_norm,
               c.addr_line, c.city, c.state, c.postal_code
        FROM USERS.CUSTOMERS c CROSS JOIN q
        ORDER BY vdist
        FETCH FIRST :k ROWS ONLY
        """
        cur.execute(sql, dict(qid=qid, k=k))
        rows = cur.fetchall()
        # Cleanup
        cur.execute("DELETE FROM query_identity WHERE qid = :qid", dict(qid=qid))
        conn.commit()
        return rows
